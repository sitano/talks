Go - язык будущего, которое уже наступило
Октябрь, 2016
Tags: go, awesome, shit

Присяжный Иван
Серверный разработчик
@JohnKoepi

* Мой опыт

- Инженер по облачной инфраструктуре в Exit Games - 2 года
- Технический лид MusicWars - 6 лет
- Разработчик на Microsoft-стэке - 2 года
- и много лет до этого C, C++, PHP, JavaScript, .NET, ...

Интересы: распределенные системы, бигдата, linux, open source

.image go-intro/intro-miner.jpg

: http://talks.godoc.org/github.com/sitano/talks/2016/go-intro.slide

* Мы строим сервис в облаке

- Развитие, анализ, поддержка систем обслуживания кластеров
- Автоматизация процессов разработки
- Интеграция Open Source продуктов в инфраструктуру
- Работа с сообществом, пачти, отчеты, ...

.image go-intro/intro-clouds.png 400 _

* Как управлять гетерогенным хозяйством?

Разделять и властвовать

.image go-intro/plant.jpg 200 _

* В поиске универсальных инструментов

- Прототипы строят на "быстрых" языках
- Что выбрать для нового проекта?
- Что выбрать для новой версии проекта?

* Люди хотят простые ответы

- Выбери самое лучшее

* Компании тоже хотят просто и дешево

* Критерии выбора

- Продуктивность
- Производительность
- Гарантиями безопасности
- Читаемость кода и легкость сопровождения
- Накладные расходы
- Область проблем - интернет приложения, сетевые сервисы (сетевые распределенные приложения в многопоточном окружении)

* Решение

- Взять лучшее из того, к чему все привыкли - C++ и Java
- Выбросить лишнее, что накопилось за последние 20 лет.

.image go-intro/golang2.png 400 _

* Итог

.background go-intro/goraster.png

* Что есть Go?

Go это компилируемый многопоточный язык программирования,
разработанный компанией Google.

Первоначальная разработка Go началась в сентябре 2007 года,
а его непосредственным проектированием занимались
Роберт Гризмер, Роб Пайк и Кен Томпсон[4],

.image go-intro/gomate.png
.link http://golang.org

* Фичи-лист

- Компилируемый, статически типизированный, C-подобный язык
- Автоматическое управление памятью, наличие безопасных указателей
- Структурная система типов
- CSP-подобная модель многопоточности

* Взлет

- 2009 - Google открыл миру Go
- 2012 1.0 (production ready, google, youtube, vitess)
- 2018 1.8 (better runtime, http/2.0, ...)

* 5 лет назад компании выбирали Scala вместо PHP, Python, Ruby, Perl, ...

* Сегодня они выбирают Go

mail.ru, Lazada Rus, Mirantis, Bell, Epam, Luxsoft, Acronis, …

.link https://kaliningrad.hh.ru/search/vacancy?text=go+language&clusters=true&enable_snippets=true&page=1 source hh.ru

Google, Netflix, Docker, Kubernetes, Dropbox, CloudFlare, SoundCloud, CoreOS, Couchbase, Uber …

* Интересные проекты

Go, Docker, Kubernetes, netstack, chaosmonkey, chain, rclone, bgp, ...

.image go-intro/chaos-monkey.png

* Итог

- Go мощный инструмент, которым легко начать пользоваться.
- Go совершил революцию в области обслуживания микросервисных архитектур.
- Go прошел период адаптации рынка. Есть проекты, которые написаны только благодаря ему.
- Go помогает писать хорошие программы, но при этом он не совершенен

.image go-intro/popularity.png 400 _

* 1С на Go???

.image go-intro/gomate2.png

* Пример

	func main() {
		bot, err := telebot.NewBot(os.Getenv("BOT_TOKEN"))
		if err != nil {
			log.Fatalln(err)
		}

		messages := make(chan telebot.Message)
		bot.Listen(messages, 1*time.Second)

		for message := range messages {
			if message.Text == "/hi" {
				bot.SendMessage(message.Chat,
					"Hello, "+message.Sender.FirstName+"!", nil)
			}
		}
	}

* Исследование 2016

.link http://metropolitan.fi/files/2016-10/2016-european-software-development-salary-survey.pdf European Software Development Salary Survey 2016

* Несовершенный Go, но очень хороший

	> So Go is simply a throwback to pre-80s programming languages, and a perfect illustration of the frustrations that led to the development and extension of the C++/Java/C# programming languages. 

.link http://talks.godoc.org/github.com/davecheney/presentations/gopher-puzzlers.slide Gopher Puzzlers - How well do you know your language? from 11 October 2016 by Dave Cheney
.link http://talks.godoc.org/github.com/davecheney/presentations/writing-high-performance-go.slide Writing High Performance Go - GopherChina from 17 April 2016 by Dave Cheney
.link http://talks.godoc.org/github.com/davecheney/presentations/seven.slide Seven ways to profile a Go program - GoBridge remote meetup from 22 September 2016 by Dave Cheney

* Generics

	type NewType []int
	type NewStruct struct {}

> No way

* Dig a little deeper...

[[https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/edit][Summary of Go Generics Discussions]]

And proceeding to YCombinator:

[[https://news.ycombinator.com/item?id=8756683][YCombinator discussion on the summary]]

And [[https://news.ycombinator.com/item?id=8757448][`Waps` commenting]]...

	> Go has generics. For arrays, slices, channels, maps, and some "standard" library functions. Go has generic functions.

So you can write

	var X map[typeA]typeB

> If you look at the compiler source, the type system has generics, to a large extent. It's simply not accessible to normal programmers, instead only allowed for golang's authors.

* Does Go have polymorphic functions?

Normally not, but…

And Waps commenting...

	> Go has polymorphic functions : append, make, copy …

* Type parameters?

	func make(Type, size IntegerType) Type
		func new(Type) *Type
	...

> Golang even has functions with type parameters. Make and new being the obvious examples. Again, this is present in the type system (not just there, also in reflect, things like printf, ...). It's simply not made accessible to us lowly go programmers.

* And, as if this is not bad enough…

> Go cheats the type system in thoroughly non-obvious ways to get more C-like behaviours that obviously do not improve safety or programmer productivity.

* Field attributes have loosy types too

	type T struct {
		V int `json: “v”`
	}

* Steve Jobs told students: 'Stay hungry. Stay foolish.'

There is a

[[http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html][50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs]]

Oh my gosh, I did not know Go is so bad… and we still successfully using it.

* Arrays and Slices

Arrays are values. Slices are views.

	a := [2]string{"a", "b"}
	b := []string{"a", "b"}
	c := [...]string{"a", "b"}
	d := make([]byte, 2, 2)

Yeah, there is a difference. What is what???

* Deep copy copy(src, dst)

Каков результат?

	arr := []int{1, 2, 3}
	tmp := []int{}
	copy(tmp, arr)
	fmt.Println(tmp)
	fmt.Println(arr)

[[http://stackoverflow.com/questions/30182538/why-can-not-i-copy-a-slice-with-copy-in-golang][The builtin copy(dst, src) copies min(len(dst), len(src)) elements]]. WAT???

* Map syntax

	Map returns
	var m map[int]string
	for k, v := range m {}
	X := m[“key”]
	If _, ok := m[“key”] {}

И над map нельзя сделать cap(m)!

А в nil map нельзя писать, тогда как в пустой slice можно.

* Currently goroutines are only preemptible at function call points.

How bad it is?

	> it's possible to write a tight loop (e.g., a numerical kernel or a spin on an atomic) with no calls or allocation that arbitrarily delays preemption.
	> This can result in arbitrarily long pause times as the GC waits for all goroutines to stop.
	> In unusual situations, this can even lead to deadlock when trying to stop the world.

* No thread monitors

- No control
- No enlisting

* For tight loops example

	func main() {
		runtime.GOMAXPROCS(1)

		x := 0
		go func() {
			for {
				x++
			}
		}()

		runtime.Gosched()
	}

.link [runtime: tight loops should be preemptible #10958](https://github.com/golang/go/issues/10958)
.link [runtime: tight loop hangs process completely after some time #15442](https://github.com/golang/go/issues/15442)

* Syscalls are … ?

	> a thread cannot both be executing code and be blocked on a syscall

[[http://morsmachine.dk/go-scheduler][On The Go scheduler by Morsing]]

synchronous.

* Cgo

Вызовы cgo реализованы через поток g0 согласно https://golang.org/src/runtime/cgocall.go

.link https://blog.golang.org/c-go-cgo
.link https://golang.org/cmd/cgo/

Почему?

	> assumed to be an operating system-allocated stack, so safe to run gcc-compiled code on

.link http://blog.altoros.com/golang-internals-part-5-runtime-bootstrap-process.htm
.link https://golang.org/src/runtime/proc.go
.link http://grokbase.com/t/gg/golang-dev/13887fgfn8/what-is-g0 by Dmitry Viukov

	> g0 is a special system goroutine.
	> Each M (thread) has own g0.
	> g0 executes scheduler code. I.e. when a goroutine finishes running,
	> execution is switched to g0, g0 chooses next goroutine to run, and
	> then execution switches to the new goroutine.
	> g0 has relatively large stack (32K) and is intended to never grow it.
	> g0 is also used for split stack management and GC.
	> The other special goroutine is gsignal, it's used for signal handling.


* Go routines exits (runtime.Exit/main, outer exit, no watch)

Как завершится?

	func main() {
		runtime.Goexit()
	}

> fatal error: no goroutines (main called runtime.Goexit) - deadlock!

* Closures out-of-scope var catch

Что выведет?

	func main() {
		for i := 0; i < 10; i++ {
			go func() {
				fmt.Println(i)
			}()


			// defer fmt.Println(i)
		}
		runtime.Gosched()
	}


* Struct{} size and ref

Каков размер struct{}?

	type S struct {
		a int
		b struct{}
	}

	func main() {
		var s S
		fmt.Println(unsafe.Sizeof(struct{}{})) // 0
		fmt.Println(unsafe.Sizeof(s.b)) // 0
		fmt.Println(unsafe.Sizeof(s)) // 16
		fmt.Println(unsafe.Sizeof(&s.b)) // 8
		fmt.Printf("%p", &s) // +0
		fmt.Printf("%p", &s.b) // +8
	}

* Mutability on value types

Что выведет print?

	type S struct {
		a int
	}

	func (s S) inc() {
		s.a++
	}

	func main() {
		s := S{}
		s.inc()
		fmt.Printf("%v", &s)
	}

* Type coercion

Скомпилируется ли код?

	type S struct {
		a int
	}

	func (s S) inc() {
		s.a++
	}

	func (s *S) inc2() {
		s.a++
	}

	func main() {
		s := S{}
		s.inc()
		s.inc2()
	}

* Error interface = nil

Каков вывод?

	type E struct{}

	func (e *E) Error() string {
		return "error"
	}

	func main() {
		var e error
		fmt.Println(e == nil)

		e = nil
		fmt.Println(e == nil)

		e = func() error {
			var x *E // == nil
			return x
		}()
		fmt.Println(e == nil)
	}
